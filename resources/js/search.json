[[{"l":"About","p":["Hello everyone, Welcome to my blog, here I will be sharing my latest findings and ideas in the fields of Digital Forensics and Malware analysis, as well as interesting CTF challenge writeups. I also have another blog where I previously posted CTF writeups and other tutorials, which you can find here."]},{"i":"who-am-i-","l":"Who Am I ?","p":["I am Nashid P (nxb1t), a Second Year BSc Computer Science student from Kerala, India. I am a passionate blogger who enjoys writing about my experiences in CTF competitions, as well as my insights and discoveries in the areas of malware analysis and DFIR. I am highly motivated to pursue a career in these fields and continuously work towards enhancing my knowledge and skills. Through my blog, I hope to share my enthusiasm with others and contribute to the community.","Core Member @TamilCTF Security Researcher & Member @InitCrew Security Researcher @SecureBinay","If you like my posts and have the means to support me, please consider supporting me here :-"]},{"l":"Contributions","p":["Added ProtonVPN artifacts plugin to ALEAPP Project","Proposed VLC Media Player adb backup artifacts for ALEAPP Project"]}],[{"l":"A Closer Look At Rust Based Malware"},{"l":"Introduction","p":["In recent years, we have seen a significant increase in the popularity of the Rust programming language. Debates have arisen around Rust's speed, with some arguing that it is faster than C/C++. Notably, Rust has also been used to write kernel drivers for the Linux kernel, which previously only supported C and Assembly code. Furthermore, many popular command-line tools for Linux have been re-implemented in Rust. One such example is the well-known bat tool, a clone of cat with syntax highlighting and other features. These made me wonder why is Rust so popular? and how effective it would be for Offensive Purposes.","In this article, we will analyse some malicious Rust binaries and check their behavior against Windows Defender.","Please note, this post is for educational purpose only. All the malware samples are created using the codes taken from OffensiveRust GitHub repository."]},{"i":"why-rust-so-special","l":"Why Rust So Special?","p":["Rust is a multi-paradigm, high-level, general-purpose programming language. Rust emphasizes performance, type safety, and concurrency. Rust enforces memory safety—that is, that all references point to valid memory—without requiring the use of a garbage collector or reference counting present in other memory-safe languages.","It is fast as C and C++ or sometimes even better.","It is LLVM based.","Easy to cross-compile.","The main reason for its offensive capabilities is the LLVM toolchain, which makes it easier to bypass static analyzers."]},{"l":"Overview Of Rust Binaries","p":["Before testing the Malware Samples, Let's look at a simple calculator program in Rust."]},{"l":"Creating a Rust Project","p":["cargo init rust_calc","Cargo.toml is the config file for cargo package manager. Dependencies and other project configurations can be defined in this file."]},{"l":"Building the Project","p":["~ 1 MB","4.8 MB","5 MB","As you can see, all the function symbols are stripped and its queit hard to understand the program flow.","Build Type","calculator output","cargo build --release to build the release version. The resulting executable will be found under the target\\release\\ directory. Here is the IDA disassembly of the both builds, they are almost same and both include function symbols.","cargo run to run the debug build.","Debug (unoptimized)","Debug Build","Function symbols expose so many informations in static analysis, so it should be stripped for better AV evasion. Fortunately, we just need to add a single line in Cargo.toml for stripping function symbols.","Here is the size of different build variants with default optimization.","IDA view of stripped Rust executable","Release (optimized + non-stripped)","Release (optimized + stripped)","Release Build","Size"]},{"l":"Testing Malware Samples","p":["In this section, we are going to test the classic Process Injection technique. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges - MITRE T1055","There are many samples with different types of techniques in OffensiveRust github repo, testing them all will make this blog super lengthy. For now, let's test the Local Process Injection and Remote Process Injection samples."]},{"l":"Local Process Injection","p":["Change the shellcode memory permission/protection to Read Execute using VirtualProtect","Copy the shellcode to allocated memory","Create a new Thread using CreateThread with the base address pointing to shellcode memory","Create Thread","Finally call WaitForSingleObject to keep the thread running infinitely","Finally the function casting exec_data eliminates the need for using Windows APIs calls like CreateThread etc.","Finding the correct function in IDA was a bit of annoying, but we can see the shellcode and all other function calls there.","IDA view of CreateThread","Let's do another test, this time using Windows APIs.","link_section specifies the section to use for a function or static, in our sample the shellcode is saved in the .text section and As a result, no need to create any RWX memory for our shellcode.","Local Process Injection - CreateThread Workflow :-","Local Process Injection - Shellcode Local Inject Workflow :-","Next question would be : how can we identify this type of Malware !?","Shellcode in .text section, starts at offset 0xcb6 and ends at offset 0xdc9","Shellcode Local Inject","Source : OffensiveRust - Process Injection Create Thread","Source : OffensiveRust - Shellcode_Local_Inject","strings","That's all for Local Process Injection, to make things even harder we can use several types of obfuscations on strings and shellcodes, hide the Windows API function traces by manually implementing them and so on. litcrypt crate is an example for string obfuscation.","The no_mangle macro disables symbol name encoding, mangling is the encoding of function and variable names into unique names so that linkers can separate common names in the language. Disabling it is essential for unsafe C codes to access the shellcode.","This is the most basic process injection, saving shellcode in the .text section of the program and execute it without any API calls.","This sample really impressed me, same shellcode but this time shellcode is in stack memory. Literally no detection, the power of Rust obfuscation is really visible here. Windows Defender static analysis were easily defeated.","VirtualAlloc allocates memory for shellcode with Read Write Permission on the current process","Well, I ran strings on the sample and it wasn't that hard to identify the Windows API functions. Even after using strip option function names were exposed, I guess it has to do with the crates we used.","Windows Defender easily caught our sample the moment it touched the disk, No wonder because we are putting plain metasploit shellcode in the .text section. Metasploit shellcodes are highly signatured, so its pretty hard to get them running most of the time."]},{"l":"Remote Process Injection","p":["Remote Process Injection is quiet different from the Local Process Injection. In this technique we are loading shellcode or DLL into the memory space of a running process and execute in its context. Imagine \uD83D\uDE01","Source : OffensiveRust - Process_Injection_CreateRemoteThread","Remote Process Injection - CreateRemoteThread Workflow :-","We input a process name in command-line arguement to our sample , eg:- rust_mal.exe notepad.exe","The pid of given process is looked up with the help of CreateToolhelp32Snapshot Windows API function","OpenProcess opens the given remote process with PROCESS_ALL_ACCESS(Gives all possible access rights)","VirtualAllocEx allocate memory in the remote process with RWX permission","Write shellcode to the allocated memory using WriteProcessMemory","Create a thread in the remote process with CreateRemoteThread function, just like in previous sample we point the base address to the shellcode memory","Finally close the process handle","In the latest Windows Defender update this sample was easily caught, but when I tested this sample before 14/02/2023 it was working rather well."]},{"l":"Final Thoughts","p":["When I tested each of these samples with Avast Free Antivirus, all of them were caught instantly. Its anti-exploit protection is impressive. Of course, highly sophisticated threat actors won't use these simple methods, but at least it can prevent skiddies.","To be honest, I was scared to see these samples in action. Rust's ability to bypass static analysis and even behavior analysis against Windows Defender is really impressive. I suggest you to install a better antivirus program such as Avast, Norton, etc. and also avoid running untrusted programs. On top of that, use a Firewall as well for better protection.","Simplewall Firewall","Thank you for taking the time to read my article. I hope it provided you with valuable insights and new knowledge. If you found it enjoyable and informative, I would greatly appreciate it if you could share it with your friends and connections. Your support means a lot to me."]},{"l":"References","p":["https://rayoflightz.github.io/re/rust/2020/05/19/Bite-Sized-Rust-RE-1-Deconstructing-Hello-World.html https://www.pwnthebox.net/rust/2020/11/01/deciphering-no-mangle.html https://cocomelonc.github.io/tutorial/2021/09/18/malware-injection-1.html https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html"]}],[{"i":"lactf-2023---forensics-writeup","l":"LACTF 2023 - Forensics Writeup"},{"l":"EBE","p":["we are given a packet capture with UDP traffic. The challenge is mentioning that someone applied RFC 3514 on the network traffic.","So Let's check what is RFC 3514.","I checked the flags of few packets and it was really interesting :-","So all we have to do is skip the packets with Evil bit, I made a script to do the job using scapy.","Flag : lactf{3V1L_817_3xf1l7R4710N_4_7H3_W1N_51D43c8000034d0c}"]},{"i":"a-hackers-note","l":"A Hacker's Note","p":["We are given a disk dump of encrypted Flash drive. Running file on the dd image file shows its a LUKS1 ecnrypted flash drive.","We have to find the password for the LUKS encryption. We can see in challenge description that the organization uses passwords in the format hacker### (hacker + 3 digits), with this clue we can do a Mask attack on LUKS encryption."]},{"l":"Decrypt the LUKS Encryption","p":["I used the LuksHeader4Hashcat python script to extract LUKS header from the dd image file.","Chose the Active-Slot 0 and dumped the keyslot to hackers-drive.dd_KeySlot0.bin. Then I run the hashcat mask attack against the key file.","hashcat -a 3 -m 14600 hackers-drive.dd_KeySlot0.bin hacker?d?d?d","After a while, I got the LUKS password hacker765.","Then I simply mounted the dd image file with cryptsetup.","Hmm, Interesting. They are using Joplin, an OpenSource note-taking app with End-To-End Encryption. Looks like they have deleted all the synced notes from the local database."]},{"l":"Sync Encrypted Notes","p":["At first I was unsure on what to do, Thanks to my teammate N1tr0s he suggested that its about syncing the encrypted-notes, I installed the Joplin app in my Android phone (Joplin is cross-platform) and copied the encrypted-notes folder to my phone storage, then setup the sync.","While setting up the sync, it asked the Master Password. It is impossible to crack the E2E encryption, so we need to find another way to get the Master Key.","I quickly googled Joplin Master Key and found an interesting discussion in their development forum.","I quickly opened the database.sqlite found in .config/joplin/ directory.","Cool, Found a Master Key : n72ROU9BqbjVOlXKH5Ju in settings table. I entered it in my Phone and boom it was the correct password.","Flag : lactf{S3cUr3_yOUR_C4cH3D_3nCRYP71On_P422woRD2}"]}]]