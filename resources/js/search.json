[[{"l":"Who Am I ?","p":["Hello everyone, I am Nashid P (nxb1t), an Incident Response Engineer. I am a passionate blogger who enjoys writing about my insights and thoughts in the areas of malware analysis and DFIR. Through my blog, I hope to share my enthusiasm with others and contribute to the community."]},{"l":"Contributions","p":["Added ProtonVPN artifacts plugin to ALEAPP Project","Proposed VLC Media Player adb backup artifacts for ALEAPP Project"]}],[],[{"l":"Blog"}],[{"l":"Why Malware Analysis Goes Beyond Sandboxes","p":["Hi everyone! This is a short post to share a thought I had while working on a malware sample: Should we rely only on sandboxes?, I started thinking about this because the malware I was analyzing wasn’t detected by sandbox environments. Here I won’t be including the in-depth analysis of reversing golang binaries, we can explore it in a future post."]},{"l":"The context","p":["I was analyzing a Linux-based GoLang binary that was designed to provide a password. Since we had sandbox environments, we simply uploaded it to see if it was safe or not.","The results from CAPE Sandbox were clean (though it was a simple CAPE setup and required some further tuning). However, when I uploaded this binary to an enterprise EDR sandbox, the results were also same (treated as not suspicious), which was interesting and weird at the same time. So I was curious about this behaviour and tried manual analysis.","Just as we use sandboxes to collect IOCs, malware developers can also gather information about sandbox environments to further improve their anti-VM and anti-sandbox techniques."]},{"l":"Role of Reverse Engineering","p":["This is where reverse engineering comes into play. To start with, we don’t need to be an “ultra pro” to figure out whether a sample missed by sandbox is actually malicious.","In our case, this particular sample was stripped but not obfuscated. Just opening it in IDA and debugging it with radare2 gave a clear picture of how the sample works. Even if it had been obfuscated, we could still have identified the malicious signs.","IDA - Some Anti-VM Insturctions","During the dynamic analysis, I found some urls from the sample which was not given by the sandbox environments.","radare2 - Extracting Urls","Apparently, there were some authentication mechanisms for the URL that were revoked. As a result, the execution wasn't completed, which maybe a reason for EDR sandbox to not detect anything or simply got exited due to Anti-VM techniques. However, the sandbox still failed to extract the URLs.","In the end, the malware sample was attempting to download files from a URL and execute them, effectively acting as a dropper.","Thanks to reverse engineering, I was able to extract more IOCs and a better understanding of how each functions in the sample works. So, in addition to using sandboxes, we should also perform reverse engineering whenever needed to verify the results.","Sandbox analysis takes an average of 5 minutes to complete. Meanwhile, performing a quick review of the binary using static analysis tools would be very beneficial. In case the sandbox misses the binary, we would still have an idea of what could have gone wrong."]},{"l":"Where to learn Reverse Engineering","p":["Starting with programming fundamentals and basic assembly instructions will give you a great head start on the path to reverse engineering. And always remember one thing : learn by doing.","Here are some of my favourite learning sources :- Crackme Challenges Github - Awesome Reversing Youtube - OALabs Youtube - Dr Josh Stroschein Youtube - pwn.college"]}],[{"l":"Practical Incident Response - Active Directory"},{"l":"Introduction","p":["A Security Analyst L1 monitors alerts and performs initial triage","A Security Analyst L2 analyzes incidents and conducts threat hunting","A Security Analyst L3 investigates complex incidents and leads response efforts","A Security Engineer takes care of maintaining security infrastructure","Active Directory Home Lab","Before continuing, please checkout the following link to setup the AD Lab used in this blog, The lab's theme is centered around a hypothetical tech company named XOPS:","Detect - Continuously monitoring security events.","Hello everyone! It’s been a while since my last blog post. This time, I wanted to make a blog on simulating Incident Response in an Active Directory environment by doing some common attack scenarios, so we can get some basic level of practical experience around this area. While I am not an expert in Incident Response, I have some basic knowledge and also really passionate about this field. Here I won't be showing how I carried out the attack simulation, I will leave it for you guys to explore on your own :).","Lessons Learned - Learning from incidents and using threat intelligence to improve security controls and prevent new threats.","Ok, What is Incident Response ? Incident response is a structured process organizations use to detect and respond to cyber threats, security breaches, and other unexpected events. The goal of incident response is to minimize damage, reduce recovery time and costs, and restore operations. There are various models for incident response lifecycle, such as PICERL, a six-step framework, and the more modern DAIR. In our blog, we will use the DAIR (Dynamic Approach to Incident Response) model, which is a five-step, continuous approach.","Preparation - Implementing security policies.","Scope, Contain, Eradicate, Recover, Remediate - Identifying affected areas, containing threats, eradicating them, and conducting recovery.","The preparation phase of DAIR is done while we setup the AD Lab. The remaining phases are done when the incident happened.","There are multiple job roles for Incident Response :-","Verify and Triage - Quickly verifying security incidents and performing analysis.","We are kind of doing the jobs of all roles in this blog :D.","You can learn more on DAIR from here."]},{"l":"The Incident","p":["XOPS, a leading player in the software market, recently fell victim to a ransomware attack. The company had only recently introduced a SOC team and had basic security configurations in place. Unfortunately, the attacker bypassed these tools and managed to compromise multiple systems. The initial entry point was a malicious software download by one of XOPS’ employees. The employee intended to download a portable version of Notepad++ from Google but was redirected to a malicious site due to search engine poisoning.","The employee only realized the infection when they noticed a ransom note on their system.","When he saw the ransom note, he quickly reported it to the relevant stakeholders. As a Security Analyst, we are assigned to evaluate, hunt and remediate the threat."]},{"l":"The Response","p":["Since there were no alerts raised by any of the security controls, we need to start from the beginning by examining the logs, analyzing the downloaded file and so on.","The tools we will use as part of threat hunting are :-","Elastic SIEM","FTK Imager","Volatility","Loki","CAPA","IDA","x64dbg","Fakenet-NG","dnSpy","The employee informed us of the specific package they downloaded and executed, which pointed us towards Notepad++. Using this information, we began our hunt by focusing on activities associated with Notepad++."]},{"l":"Log Analysis","p":["Additionally, we didn't find any data related to the creation of the ransom note.","After that, we didn't see any telemetry from the C2 machine towards the Domain Controller or any other systems, suggesting that the attacker was unable to escalate further. We also checked the DC logs and didn't saw anything unusual.","Based on the initial information, we identified two key events related to the Notepad++ package in the event logs : the first one was a FileCreate event ( ID - 11), indicating the package was saved on the system, and the second was a Process Creation event ( ID - 1), showing that the application was executed.","Based on the timeline of the evil-winrm execution, we reviewed the logon events related to the bkp_op user to verify if any lateral movement from the compromised Ubuntu server had occurred.","By examining the cmd process, we noticed an interesting command line associated with it. The parent process was Powershell, and its command line revealed that it was fetching a file from an external website and executing it in hidden mode.","Checking Child Process of Second Loader using Analyzer","Commandline Arguements of Child Process","Correlating Logon Events with Process Creation","Creating Timeline","Execution of Evil-WinRM","Focusing on the Process Creation event ( ID - 1), we observed details such as the process name, arguments, and parent process information. The process name and parent process stood out in this context, indicating unusual activity. Specifically, the process name didn't align with typical Notepad++ behavior (npp.dll), and the parent process (cmd.exe) was not one usually associated with launching a legitimate application like Notepad++.","However the npp.dll is actually notepad++.exe and the attacker renamed it for crafting an attack path based on the shortcut file.","LDAP Queries","Loader Process Hash","Looking back to network connections, we can see a connection to ssh. Which indicates the attacker likely used pivoting to access the internal network of the compromised machine.","Looking for any service tickets Requested ( ID - 4769) for any user in the same timeframe as the ldap queries, we can see one event stands out for username bkp_op. Kerberoasting tools like Rubeus by default request service tickets using RC4 (0x17) encryption, which is weak and easy to bruteforce. Moreover, the Ticket Options is also unique compared to legitimate ticket requests.","Missing Events related to Ransom Note","Network Connections Initiated by the Process","Network Login Events related to bkp_op User","Notepad++ Process Creation","Parent Process Commandline","Process Commandline Arguements","Searching Notepad++","Second loader hash","SSH Logins","The attacker used the same loader but modified its name. The hash of both loaders are identical: ac18ceefb605f3b87c5becb64a2320bc1cfa2c97345cc1abd9efb62fee8ffc2c","The bkp_op user is part of Backup Operators group which gives him SeBackupPrivilege, this privilege can bypass all ACLs and allow the user to read most of the System files. The attacker leveraged this privilege and dumped the SYSTEM and SAM registry hives.","To gain a better understanding, we correlated logon events with process creation on the C2 machine. This approach helped us map out the activities and interactions between logins and processes, providing clearer insights into any lateral movement or further exploitation that occurred.","Using Process Analyzer","Using the analyzer feature, we were able to view all the child process created by the Powershell process.","We also recall the attacker querying PuTTY's SshHostKeys, which might have been an attempt to identify SSH sessions that could be used for lateral movement. Additionally, we observed a new login from the bkp_op user, indicating further escalation within the network.","We can leverage the timeline feature in Kibana ( Security --> Timelines --> Create New Timeline) to gain a broader understanding of the PowerShell process. By reviewing the timeline, we can piece together related events and activities surrounding the PowerShell execution, such as subsequent actions, and interactions with other processes or network connections.","We can see the commandline arguments of all child process spawned by the malicious Registry process, indicating that certain enumerations like ip lookup, user lookup and querying ssh information being conducted.","We can see the file creation event have a notepad++.lnk shortcut file being saved, which is really unusual for a portable program.","We had the /tmp/ folder under monitoring with auditd, so using that filter, we can see all programs executed from it. The attacker used evil-winrm from the /tmp/ folder, indicating an attempt to access other machines within the network.","We noticed a process named Registry.exe spawning numerous child process. Additionally, the process name mimics the legitimate Windows process Registry. We obtained the process's SHA-256 hash: ac18ceefb605f3b87c5becb64a2320bc1cfa2c97345cc1abd9efb62fee8ffc2c, which will be useful for IOCs.","We observed the creation of the process wsmprovhost.exe, which indicates the establishment of a WinRM session on the host. The subsequent process chain reveals the dropping of another loader, suggesting that the attacker continued their activities by deploying additional malicious tools.","We will start by examining the LDAP queries. By focusing on the time range from the first LDAP request to the last made by the process, we can isolate several queries. Among these, the first and second queries stand out. Notably, the second query is associated with the Kerberoasting technique, which is used to retrieve all Service Principal Names (SPNs) and their associated accounts.","Weak Kerberoast Service Ticket Request","While examining the network connections created by the malicious process, we noticed connections to the same IP address from which the executable was downloaded, but on an HTTPS port, indicating a potential C&C connection. Connections on port 8080 likely correspond to staged payloads. Additionally, we observed connections to LDAP initiated by the same process."]},{"l":"Memory Forensics","p":["Based on the previous analysis we can assume its a C2 beacon as many C2 frameworks utilize CLR for inline-execution of .NET assemblies to avoid security controls. We can utilize the Volatility windows.vadyarascan module to scan memory regions to identify any known C2 framework shellcode. If no known signatures are found, additional analysis of the sample will be required. In our case, the yara rule for Havoc C2 got a match.","Dump loader process memory","Extracted executables from the process memory","Havoc agent details","Havoc yara rule match","Here we used the Foremost tool to extract the executable files.","Loaded Modules","Scanning for malicious files using Loki tool","Scanning those files using loki showed the presence of SharpSploit related files.","Since its Havoc C2, it is high likely the attacker utilizing inline-execution function to execute .NET programs based on our previous finding about clr.dll. If that's the case, then those programs could stay in memory and we can extract them by dumping the loader's process memory.","Some files weren't detected by loki indicating its not a known malicious file, we can analyse them further during the Malware Analysis time.","Suspicious .NET executable","The memory dump from C2 Machine didn't had any new tactics or techniques and were almost similar.","Through log analysis, we were able to understand the attacker's path, the TTPs they used, and the network-level IOCs. To identify the tools used and, in particular, to decrypt the ransomware-encrypted files, we need to analyze the memory of the loader process. After isolating the client machines we took memory dump, the ubuntu machine didn't had anything unusual running.","To get more detailed information about Havoc payload, like agent id and encryption keys, we can use a volatility plugin created by ImmersiveLabs. If we were caputing network packets we could utilise this information to decrypt them and get more insight on the C2 communictaions, anyway in our lab we were't capturing network packets.","Using volatility3 we can look at the modules loaded by the loader process, in it the clr.dll really stands out. clr.dll only comes in context of a program either if its a .NET application or it explicitly loads clr.dll to interact with CLR runtime."]},{"l":"Host Analysis","p":["While analyzing the logs, we didn't observe any persistence techniques used by the threat actor on any of the Windows machines. We also manually checked for backdoors in the autorun directory and other common locations, but found nothing. However, our Ubuntu machine had the least telemetry, so we need to check if any persistence mechanisms were added on that host.","From the logs, we verified that the attacker did not escalate to higher privileges, as the bkp_op user was not in the sudoers group. Upon examining the .bashrc file, we found an interesting entry pointing to another .bashrc file in the .local directory.","Upon checking, it turned out to be a Bash reverse shell."]},{"l":"Malware Analysis","p":["After analyzing the loader, we examined the suspicious binary extracted from memory, which turned out to be a .NET executable. By decompiling it with dnSpy, we confirmed that it was the ransomware responsible for encrypting files. The ransomware used RC4 encryption and the encryption key was visible in the binary. With this key, we were able to decrypt the encrypted files.","After fetching the staged payload reg, the loader seems to do decryption using the 0xdeadbeef string. Because we couldn't find any traces of our dummy program in-memory, which means the dummy program became gibberish due to the decryption operation.","Checking loader Capabilities using CAPA","CLR Mechanism in loader","Decompiling the extracted binary from memory","Function utilizing AMSI bypass","Going further, we encountered an interesting string. Its been processed inside a loop with range 256 which sort of correlates with CAPA result of RC4 encryption.","Hardware Breakpoints at AmsiScanBuffer and NtTraceControl","Interesting string found","Key for RC4 Decryption","Loader Main Function in IDA","NtGetThreadContext and NtSetThreadContext function calls were also seen, which are used to set hardware breakpoints.","Once the payload is decrypted, the loader creates a new CLR instance effectively executing the .NET assembly in-memory.","python -m fakenet.fakenet","RC4 Encryption Match","So I had to run fakenet-ng as a python module and implementing the fix as mentioned in the github issue here.","Starting with the loader, we can use capa tool to assess its capabilities. While we observed many features, not all of them may be true positives. But this gives us an high level overview of the loader's capabilities. Capa also showed that this loader is a rust compiled binary.","The RC4 match was PRGA.","Using NtGetThreadContext and NtSetThreadContext","We can use IDA for static analysis of the binary. In the main function we found a function related to VEH (Vectored Exception Handling), which can be employed to evade Endpoint Security Controls.","We created a dummy .NET program named reg and hosted it in our localhost using fakenet-ng. By redirecting traffic to localhost, we conducted dynamic analysis using x64dbg. We can see the hardware breakpoints being created at AmsiScanBuffer and NtTraceControl using NtSetThreadContext API, the address of the AmsiScanBuffer and NtTraceControl can be seen at Dr0 and Dr1 registers, this is done initially before loading the staged payload to evade security controls.","We discovered a function that loads amsi.dll and looks for function AmsiScanBuffer, further down it also had function looking for NtTraceControl. But there weren't any patching signs, so since its using VEH this has to be a patchless approach by setting up exception at function entry.","We need to thoroughly analyze the loader and its associated files. From the YARA scan we previously conducted, we identified some of the executables, including SharpChrome and SharpUp, as well as another executable with no known signature. We will analyse the loader and the files extracted from memory which weren't detected based known signatures in a sandbox environment.","While i was using the exe version of fakenet-ng, I encountered an error (Error 87) which prevented the request redirecting to localhost."]},{"l":"Attack Overview","p":["-",".NET based Ransomware","After conducting a thorough analysis of the endpoints, we were able to piece together the entire attack path and TTPs used. The attacker choose to deliver malware via malicious shortcut file, this is a widely used technique by Threat Actors, especially in malware campaigns like Qakbot.","Attack Path Diagram","Bash Reverse Shell","Command and Control","Credential Access","Data Encrypted For Impact","Defense Evasion","Discovery","Drive-by Compromise (Malvertising)","Execution","Havoc C2","Impact","Indicator Blocking (Etw and AMSI Patching)","Initial Access","Kerberoasting, Credential From Web Browsers","Lateral Movement","ldapsearch","Malicious File (Shortcut File) , Command and Scripting Interpreter (Powershell)","Persistence","Remote Discovery (Querying Domain Joined Computers)","Rubeus, SharpChrome","Rust Loader","SSH, EvilWinRM","SSH, Windows Remote Management","T1018","T1021.004, T1021.006","T1071.001","T1189","T1204.002, T1059.001","T1486","T1546.004","T1558.003, T1555.003","T1562.006","Tactic","Technique ID","Technique used","Timeline is really important in Incident Response, since the blog have became queit long i have skipped that part, but you can check here to learn more on that topic.","Tools used","Unix Shell Modification","Web Protocol (Using HTTPS as C2 channel)"]},{"l":"Detection Engineering","p":["From this incident, we gained valuable insights, such as the need for a proper alerting mechanism, better password policies, and other improvements. In this section, we will focus on creating alert rules and policies to ensure timely detection and response to similar attacks in the future."]},{"l":"Detecting CLR Loader","p":["While analyzing the loader's memory, we found an indicator that may suggest the execution of .NET assemblies in memory: the presence of CLR DLLs, the loader was written in rust so no way it loads clr.dll by default. So by tweaking our sysmon config we can add more visibility on module loading and detect if any malicious beacons are running in our system.","The given rule is a basic one that logs when clr.dll is loaded by any process, excluding those running from the Windows directory. As a result, even if a normal .NET application is run, it will be logged. This may lead to false positives, but with proper correlation, we can identify potential CLR loaders and inline execution of .NET assemblies.","After manually updating the Sysmon configuration on the client machines, I re-ran the loader, and we can now observe the loading of clr.dll by the Registry process.","Detecting CLR Dlls Loaded By the Loader","To quickly detect the loader if someone downloads it again, we need to create a YARA rule based on the indicators of compromise (IOCs) identified during malware analysis. These IOCs include unique strings, imported functions, and techniques such as setting hardware breakpoints at AmsiScanBuffer and NtTraceControl. Using this information, we can craft a YARA rule for this specific sample.","Yara rule working as Intended"]},{"l":"Detecting Kerberoasting","p":["Add the name of rule , description and severity. We can additionally add MITRE TTP and on what integrations this rule depends on , what are the false positive and so on.","Adding Action Connectors","Adding Rule Query","Alert Triggered","As you can see, our rule successfully triggered when the attack was conducted.","Creating New Alert Rule","Detailed View Of Alert","Elastic SIEM Rules","Here I am repeating the kerberoasting attack by pivoting to internal network and using Impacket-GetUserSPNs.","Investigating the alert on timeline give more details about the events took place.","Kerberoasting is a very serious security issue we need to continuosly monitor. During log analysis, we detected kerberoasting attempts, based on the queries we can create an alert rule to quickly notify us in case of any potential Kerberoasting attempt.","Kerberoasting using Impacket","This is the correlation rule we developed to detect Kerberoasting attacks in our lab's context. Whether through inline execution or network pivoting, when a beacon attempts Kerberoasting, it will establish a Kerberos connection on port 88. By correlating this with any weak TGT requests and considering ticket options used by tools like Rubeus and Impacket-GetUserSPNs, we can detect these attacks in a timely manner. However, if the attack originates from a compromised Linux system, we would need to create a separate rule that focuses solely on Service Ticket Requests without correlating to any specific process.","We can add connectors for instant notifications when the rule is triggered, in our case I selected none.","We can create new alert rules in Elastic SIEM by going to Security --> Rules --> Create new rule.","What if the attacker only searched for SPN accounts without proceeding with Kerberoasting? This is where LDAP query monitoring becomes useful. By creating an alert for potentially malicious LDAP queries based on event log 1644, we can detect the presence of malicious actors early on. Additionally, incorporating deception techniques, such as a decoy user with an attached SPN, can help detect potential Kerberoasting attempts while minimizing false positives."]},{"l":"Detecting Browser Credential Stealing","p":["Credential theft is a serious issue that we must actively defend against. If compromised credentials belong to high-privileged users in cloud or other infrastructures, it significantly increases the attack surface and potential damage to our organization. During our Memory Forensics Analysis, one of the executables we extracted from the process memory was SharpChrome, which abuses the DPAPI (Windows Data Protection API) to list all saved passwords in Chromium-based browsers.","Netero1010 has beautifully explained detection strategies in his blog, He utilizes File Object Access auditing for detecting these type of attacks.","One detection blindspot he mentioned was utilizing process injection. In that case, the credential-stealing activity would appear to originate from the legitimate browser process.","So, Let's simulate the blindspot scenario of injecting shellcode into chrome process and running SharpChrome from there.","Remote Process Injection","Shellcode successfully injected into chrome process (PID - 5764) and we ran the SharpChrome with the dotnet inline-execute method.","Executing SharpChrome from the Injected Process","When we check the Chrome processes in Process Hacker, we can see that one Chrome process (PID - 5764) is highlighted in green, indicating that it has .NET assemblies loaded.","Chrome Process List","When we check event ID 4663, we can see that the injected Chrome process has accessed the Login Data and Local State files, which at first glance may appear to be legitimate activity.","In the generated event, process id is shown in hex format, thats why I entered 0x1684 in query which equals to 5764.","File Object Access Event","As a detection strategy for this blindspot, we can correlate the file object access event with the Sysmon rule we created earlier.","Correlation of Events"]},{"l":"Detecting Evil WinRM","p":["For detecting the use of Evil-WinRM we can either utilize the strategies like correlating the process creation and login event","or I found a nice blog by cY83rR0H1t with even better approach using event ids 4103 and 800."]},{"l":"Detecting Linux Persistence Mechanisms","p":["Checkout Elastic Security's Primer on Persistence Mechanisms for a detailed walkthrough on detecting persistence mechanisms and linux detection engineering."]},{"l":"Conclusion","p":["Through this blog i hope you guys got a basic understanding of practical steps in Incident Response. In an enterprise scenario the logs would be huge and without proper threat hunting and detection engineering skillset it would be hard to find the threats and contain them on time with minimal impact."]},{"l":"References","p":["Intrinsec - Kerberos OPSEC","No Hassle Guide to EQL for Threat Hunting","ImmersiveLabs - Havoc C2 Defensive Operators Guide","MDSec - Detecting and Advancing In-Memory .NET Tradecraft","Dr Josh Stroschein - The Cyber Yeti","Cyber Attack & Defense","Attack Detect Defend"]}],[{"l":"Active Directory Lab","p":["Hello everyone, welcome to my blog on setting up a simple AD lab for practicing Incident Response, Threat Hunting, and Digital Forensics. Once set up, the lab can be easily customized based on use cases, making it more flexible. In this blog, I am focusing only on a host-based incident response scenario, so the policies and integrations I am adding are tailored to that. To make the lab more realistic, the lab's theme is centered around a hypothetical tech company named XOPS."]},{"l":"Setting up the Lab","p":["1GB","2GB","After joining the domain, we have to configure few settings to make sure home directory are correctly generated for the domain users, also to make login easier by removing the need of entering domain name along with username (e.g user instead of user@xops.local).","CLIENT 1","CLIENT 2","Configuring Ubuntu Server to join AD Machine","Edit /etc/sssd/sssd.conf and make sure the following line are included, this will allow domain users to ssh login using only their username without the need of specifying domain name.","In this lab we are only using Windows Defender as endpoint security product and not relying on any EDR/XDR products.","Lab Diagram","Machine","RAM","Restart the sssd service to apply all changes .","Then run the following command to automatically create home directory for domain users.","This is how my setup looks like, I have 16 GB of ram in my system, so if yours is less you can reduce the number of client machines.","Ubuntu Server","We need to configure ubuntu server to allow AD users ssh login via LDAP. Configuring it is relatively simple. Make sure to set DNS in /etc/resolv.conf to the IP of DC, in my case its 172.16.0.1.","We’re building the infrastructure for XOPS, which includes both Windows and Linux machines connected to the AD environment. The Linux systems are primarily used for automation and backup services. Certain users are restricted to logging in only on specific computers, and the Linux server has LDAP enabled for SSH authentication.","Windows Server 2019","You can refer to Active Directory Lab by AdiH8 for setting up the DC and configuring a basic AD Environment, this requires manual interactions, but if you prefer automated setup you can use GOAD project."]},{"l":"Configuring Logging On Machines","p":["In this section we will setup logging mechanisms for both Windows and Ubuntu Machines."]},{"l":"Setting Up Auditing in Windows Machines","p":["--> LDAP Query Monitoring","--> Powershell Logging","-> Kerberos Auditing Kerberos events gives us better visibility into how tickets are used and helps detect malicious actions related to Kerberos.","-> Logon Auditing Logon events help us identify any malicious or anomalous behaviors related to user logons.","-> Privilege Auditing Sensitive privilege events helps us identify unusual usage of elevated permissions and privileged users.","1","15 Field Engineering","1644","2","3","4","4103","4104","4624","4672","4673","4768","4769","4964","5","A Kerberos authentication (TGT) was requested","A Kerberos service ticket was requested","A privileged service was called","Action","Active Directory provides auditing capabilities, with audit policies created and managed through Group Policy Objects (GPOs). These audit policies provide visibility into various security-related activities, such as account logon attempts, changes to user accounts, access to sensitive resources, and system-level events.","An account successfully logged in","Base","Decimal","Description","Event ID","Expensive Search Results Threshold","Hive","HKEY_LOCAL_MACHINE","Inefficient Search Results Threshold","Kerberos Auditing: Account Logon -> Audit Kerberos Authentication Service , Audit Kerberos Service Ticket Operations","Key Path","Logon Auditing: Logon/Logoff -> Audit Logon , Audit Special Logon","Monitoring LDAP queries offers an advantage in detecting potential Kerberoasting and AS-REP Roasting attempts.","New GPO can be created by right clicking on Domain in Group Policy Management application in DC Machine.","No","Powershell logging is essential to identify malicious scripts run on endpoints, it can be enabled under :-","Powershell Module Logging","Powershell Script Block Logging","Privilege Auditing: Privilege Use -> Audit Sensitive Privilege Use","REG_DWORD","Search Time Threshold (msecs)","So, for detailed logging of ldap queries, we will enable ldap client verbose by updating 4 registry keys.","Some of the important policies and their corresponding event ids we will focus on this blog are :","Special Group has been assigned to new logon","Special privileges assigned to new logon","SYSTEM\\CurrentControlSet\\Services\\NTDS\\Diagnostics","SYSTEM\\CurrentControlSet\\Services\\NTDS\\Parameters","These event logging can be enabled under","This event logs an entry for each LDAP search made by a client against the directory that breaches the inexpensive and/or inefficient search thresholds.","Update","Value data","Value name","Value type"]},{"l":"Installing Sysmon","p":["1","11","3","7","Description","Event ID","File Create","Finally create the GPO and add the batch file in Startup scripts, apply gpudate /force on clients and reboot.","Image Loaded","Network Connection","Process Created","Some Important event ids generated by Sysmon are :-","Sysmon offers enhanced logging capabilities for process creation, network connections, and file access-related information. Deploying Sysmon in any Active Directory (AD) environment is highly recommended for improved security monitoring.","Then we have to add Domain Computers group read access in share, which makes the share accessible for all computers.","Use sc query sysmon64 to verify the Sysmon Service is running.","We can deploy Sysmon on all systems using GPO policy. Download the Sysmon executable and create a share in the DC for deployment. Sysmon's power relies on how we configure the tool, by default sysmon doesn't offer high level of logging, but with proper configuration we can improve it. I used SwiftOnSecurity's sysmon config as the base config as it covers starter rules, we can modify from there based on our needs.","We can use batch script to automate sysmon deployment, this will make things easier and we don't need to go to all machines and install from there manually."]},{"l":"Configuring Ubuntu Machine","p":["For setting up logging in ubuntu we will use auditd. auditd is the Linux Audit daemon responsible for tracking and logging system activities. It provides detailed event records, including file access, user actions, and security policy changes, making it valuable for monitoring and incident response.","By default auditd only logs events like ssh login, use of sudo, pam. This is great but can be improved to get more telemetry from the systems. We can monitor specific files and folders for any modifications being occured there. Monitoring /tmp/ folder is highly useful to trace if any data is being dumped there and so on.","We can monitor tmp folder by applying this auditd rule :","What it does is, monitor tmp folder for any read,write,execute,append actions performed. Then we have to restart auditd service to apply the rule."]},{"l":"Installing SIEM Agents on Machines","p":["For SIEM, ELK stack is the best free option. Elastic even provides a 14 day free trial of their cloud version so we don't have to setup anything locally.","Once the free account is created, Install the elastic agent on the DC and clients, refer here for a detailed guide on installing the agents. Agents can be also deployed using GPO, but here i installed them manually on clients and DC.","Once the agents are installed, enable the System integration and Windows integration for the agents. These two integrations will forward events from Application, Security, Sysmon and Powershell/Operational event log channels.","For DC, we need to create a separate agent policy and add one more additional integration named Custom Windows Event Logs to collect LDAP queries.","In the channel name enter : Directory Service.","And for linux machines, we need to use auditd integration.","With this, our Lab is setup to log many of the events and we can conduct different types of attack simulations for learning Incident Response, Digital Forensics and Threat Hunting. You are free to add more integrations and logging mechaninsms to make this lab even better for your use-cases.","Check out an example Incident Response scenario based on this Lab :-","Practical Incident Response - Active Directory"]},{"l":"References","p":["GPO Monitor LDAP Queries","Build it Before Breaking It"]}],[{"l":"Android Forensics - An Introduction","p":["Hello Friends, In this blog, we will explore Android Forensics, the process of acquiring Android device, anti-forensics techniques, and a practical example on analysis and recovery of deleted files from an Android device image."]},{"l":"Key Terminologies used in this blog","p":["Acquisition : The gathering of sensitive data during a digital forensic investigation","Forensically Soundness : The application of a transparent digital forensics process that preserves the original meaning of data for production in a court of law","Disk Image/Dump : A disk image/dump is a file containing the contents and structure of a disk volume or of an entire data storage device.","ROM : Android Operating System, Stock ROMs are the Android OS which comes preinstalled with the phone. Custom ROMs are the modified Android OS maintained by open source communities.","Block Device : Block Devices tend to be storage devices, capable of buffering output and storing data for later retreival. HDD, SSD etc are example for block device."]},{"l":"Why Android Forensics"},{"l":"To Support An On Going Crime Investigation","p":["Android Forensics helps in finding Digital evidence from Android Phones related to an ongoing criminal investigation. If the accused is using Apple iPhone, iPhone forensics is applied. People use Smartphones for both digital crimes and non-digital crimes. So Analysing these devices are crucial to solve the investigations."]},{"l":"To Identify Malware","p":["Malware attacks on smartphones have grown big recently. At least a single person in a household now owns a smartphone. Most people do banking and purchasing through their smartphones. This has attracted many threat actors. Varying from simple key loggers to ultimate Spywares ( like Pegasus) that keep spying on victims 24x7, the smartphone threats have become scary. Android Forensics and Mobile Forensics in general help in identifying these threats on the incident."]},{"l":"The Android Forensics Procedure","p":["Sieze and Isolate: Seize the device (Mostly done on criminal investigations) and Isolate it to avoid Tampering data.","Acquisition: Create a copy of the device storage or files.","Decryption: Decrypt the storage if its encrypted.","Analysis: Analyse the collected evidence."]},{"l":"Types Of Android Device Acquisitions","p":["Physical Acquisition The process of creating a bit-by-bit copy of the storage device is known as Physical acquisition. With this method, we can analyse deleted files and system files. This type of acquisition can be done using software with elevated privilege (root access) or directly imaging the storage device using JTAG Interface, EDL Mode (bootloader implemented by SOC devs).","Logical Acquisition In this process, we are copying existing files from the device storage. Which means we can't analyse the deleted files and also key system files of the Android OS. This type of acquisition doesn't require root access.","Cloud Acquisition This method relies on cloud backup and other cloud data source. For example, WhatsApp chats can be analysed using WhatsApp cloud backups.","UFS (Universal Filesystem Storage) 3.0 - Read/Write Speed ~ 2900 MB/s","eMMC (Embedded Multi-Media Card) 5.1 - Read/Write Speed ~ 256 MB/s","Easy JTAG Box with eMMC and UFS Interface"]},{"l":"Android Forensics Tools","p":["Autopsy is a GUI front-end of TSK with many custom modules and add-ons.","Autopsy Sleuthkit","Belkasoft Evidence Center X","Cellebrite UFED","Cellebrite UFED is a powerful platform to dump and analyse different portable devices like Mobile Phones, Drones , SIM card etc.","Description","Easily acquire forensic images of any iOS or Android device, hard drive, and removable media","Evidence Center X is a flagship tool by Belkasoft for computer, mobile and cloud forensics. It can acquire and analyze a wide range of mobile devices and computers.","License Type","List of different tools used in the Android Forensics realm.","Magnet Acquire","Magnet AXIOM","Magnet AXIOM is another platform capable of analyzing wide range of mobile devices.","Oxygen Forensics Detective","Oxygen Forensics Detective is an all-in-one forensic software platform built to extract, decode, and analyze data from multiple digital sources.","Sleuthkit (TSK)","Tool Name","TSK is a collection of command line tools and a C library that allows you to analyze disk images and recover files from them."]},{"l":"Android OS","p":["Android is a mobile operating system based on modified version of the Linux kernel. Android's kernel is based on the Linux kernel's long-term support(LTS) branches.","Android has another operating system, Trusty OS, which is Google's implementation of a Trusted Execution Environment (TEE) OS that runs alongside Android. TEE is a secure area of the SOC chip. This enables Hardware-backed keystorage to ensure encryption and decryption keys are securely handled. As a result the keys are never loaded in the RAM and is protected from many ram based attacks."]},{"l":"Android Partitions","p":["Android Framwork","boot","cache","Contains a kernel image and a generic ramdisk","Contains proprietary files which are not distributed with AOSP, ie system applications and libraries added by OEMS","Contains some preloaded system apss and regional settings which are installed on first use","Contains the recovery image. The recovery image holds a recovery program that lets the device boot into a recovery console for performing advanced recovery and maintenance operations. It contains a second complete Linux system i.e. independent OS, including a user-interface application, kernel and the special recovery binary that reads a package and uses its contents to update i.e, flash or wipe itself or any other partition particularly during OTA updates","Contains user-installed apps, media files and other user data","cust","Description","In this section, we will cover the important partitions which are same across Android versions.","misc","Partition Name","recovery","system","Temporary data storage","There are several partitions in Android devices that serve different functions of boot process. Google introduced new changes to partition layout since Android 11 and it is even more tweaked in the recent Android 13 update (as of writing this blog).","Used by recovery partition","userdata / data","vendor"]},{"l":"Android Disk Encryption","p":["Android uses FDE (Full-Disk Encryption) and FBE (File-Based Encryption) schemes to encrypt the internal storage. FDE was used as default from Android 5 till Android 9, since Android 10 FBE is used the default encryption scheme."]},{"l":"Full-Disk Encryption (FDE)","p":["Android full-disk encryption is based on dm-crypt, which is a kernel feature that works at the block device layer. The encryption algorithm is 128 Advanced Encryption Standard (AES) with cipher-block chaining (CBC) and ESSIV:SHA256. The master key is encrypted with 128-bit AES via calls to the OpenSSL library. Upon first boot, the device creates a randomly generated 128-bit master key and then hashes it with a default password and stored salt. The default password is: default_password However, the resultant hash is also signed through a TEE (such as TrustZone), which uses a hash of the signature to encrypt the master key. The device can be encrypted using PIN, Password, Pattern or with the default password. One of the limitation of FDE is that the phone will be usable only after entering the credentials on boot, this is also known as Secure Startup. Which means, SMS, Receiving Calls , alarms and other services are not available if credentials are not provided. Most OEMs use default password for encryption.","FDE is suspect to these types of attacks:-","Bruteforce Attack: Bruteforcing the lockscreen using adb or an HID interface. Bruteforcing takes lots of times because OEMs use different schemes in their lockscreen timeout and also if the PIN/Password is long it will be relatively impossible to crack.","Cold Boot Attack: FDE decryption keys were loaded in RAM for decryption process. The keys can be extracted by creating a memory dump after cooling the RAM module. This attack is obsolete these days."]},{"l":"File-Based Encryption (FBE)","p":["FBE allows different files to be encrypted with different keys that can be unlocked independently. FBE introduced a new boot method called Direct Boot. With Direct Boot, encrypted devices can boot straight into lock screen. On an FBE-enabled device, each user of the device has two storage locations available to applications: Credential Encrypted (CE) storage, which is the default storage location and only available after the user has unlocked the device and Device Encrypted (DE) storage, which is a storage location available both during Direct Boot mode and after the user has unlocked the device. Phone Dialer, Alarm and other important applications run on the DE storage after boot.","Secure Startup Option in MIUI 11","Secure Startup Lock Screen"]},{"l":"Physical Acquisition of an Android Device","p":["Please note that the procedures mentioned in this blog are intended for an overview of acquiring Android devices. In real-world scenarios, such as in forensics labs, devices are isolated and protected from any form of data tampering, they also use professional tools for acquisition and analysis. Simulating those methods in a home lab is not feasible.","Let's do Physical Acquisition method on a FDE encrypted Android device.","Device Specifications :- Model : Xiaomi Redmi Note 6 Pro (Tulip) ROM/OS : MIUI 11 (Android 9) Recovery : TWRP Custom Recovery Encryption : FDE ( with default password )","Required Tools:","Android SDK Platform Tools"]},{"l":"Preparing The Device","p":["Unlock Bootloader : Each Manufacturer has different methods to unlock bootloader. Refer to device forums to find the correct procedure, also please note that some manufacturers don't allow unlocking the bootloader.","Install Custom Recovery : There are many custom recovery projects for Android. TWRP Custom Recovery is the most popular one among them. We can start a temporary recovery session with the commands given below. To Permanently install TWRP in the device, refer to this XDA Forums Post","TWRP supports decryption of both FDE and FBE, If the device is encrypted with the default password, TWRP will automatically decrypt the storage. Otherwise, the user will be asked to enter the password/pin code.","Data(userdata) partition and Cache partition are mounted by default in recovery. Only the mounted partitions are decrypted, so if we have to dump the System partition or any other partitions, we will have to mount them. Partitions can be mounted through the Mount option.","TWRP Menu --> Mount","TWRP Recovery Menu","TWRP Mount Section","We can determine the type of encryption by running the following command through adb. If the result is block, then it is FDE or if the result is file, it is FBE encryption.","Check device encryption","FDE encrypted storage","FBE encrypted storage"]},{"l":"Dumping Data Partition","p":["Firs of all we have to determine the name of data partition. As we know, FDE encryption is based on dm-crypt, so the decrypted partition will be mounted on separate block device. We can list the mounted partitions through adb with the following commands :-","But before that, I will boot my device into Recovery Mode ( either with adb or by pressing the volume up button and power button, it will vary from device to device). Because Android doesn't allow root permissions via adb while its running in standard mode.","adb can't run with root permissions","After booting into recovery mode","Here we can see /dev/block/dm-0 which is mounted on /data mountpoint. That's the decrypted data partition we need to dump, because the custom recovery automatically decrypts it using the default password.","In the below image, we can see a block device named mmcblk0, which is equivalent to the /dev/sda device file we see in linux distros.","Block Devices List","Dumping partitions are really easy, and the time consumption may vary depending on the partition size and speed of the devices. In our case, the internal storage size is 64 GB and the data partition around 50 GB. So, I dumped both mmcblk0 block device and the dm-0 block device, which totals to over 100 GB. mmcblk0 is the encrypted internal storage, so I named its dump encdisk.img and for dm-0 I named it decdata.img.","Block device names might vary depending on the devices, so make sure to enter the correct name while dumping the partition.","We will use the adb pull command to dump the block devices/partitions.","Dumping data partition and entire storage"]},{"l":"Analysing The Forensic Image","p":["Ok, Now we can analyse our dumped data partition image using Autopsy Software.","Open Autopsy and Select New Case , Enter required info.","Autopsy New Case","Select Disk Image as source type.","Select Data Source","Select the required Modules, In our case I have only selected Picture Analyzer, Photorec, Central Repo and Android.","Autopsy Modules","Once it starts processing the image, we can see many data artifacts such as call logs, contacts, messages etc in real-time.","Artifacts List","We can also use TSK command-line utilities to access forensic image contents, its really liteweight on the system but involves lots of manual work."]},{"l":"TSK command-line reference:-","p":["fls : fls lists the files and directory names in a file system.","mmls : mmls displays the contents of a volume system (media management).","icat : icat outputs the contents of a file in a disk image to STDOUT.","TSK usage example","In the below screenshots, we have used mmls on the encdisk.img. Only a few partitions like the cache are unencrypted. Userdata and other important partitions are encrypted. More TSK commands and their usage can be found in Sleuthkit wiki","mmls","Listing files of different partitions"]},{"l":"Recovering Deleted Files","p":["Before recovering the deleted files, let's see what's happening under the hood."]},{"l":"How Data Recovery Works:-","p":["When we store files in hdd/ssd, the files are stored in blocks. Each block contains a piece of the file. The first block usually contains the metadata for the file. When we delete a file, only the first block which contains metadata is deleted. The operating system can no longer detect the file because it's metadata is lost hence considers the blocks free for writing new file. Recovery tools read the storage sectors one by one, block by block, and find correlated blocks. Once all the correlated blocks are found, the recovery utilities remake the metadata. Since the blocks are marked free, there is a high chance of blocks getting overwritten by new files, hence the recovered files might have the contents of an already existing file. So, It is highly recommended to recover file as quickly as possible to prevent overwriting.","For most of the users, Autopsy would be enough to recover the deleted files as it includes the tools listed below, selecting all the files in Deleted Files category and exporting it to the desired folder will do the job. But if you are using a low spec system and a data source with many files, then Autopsy won't be a good option. Let's check at some command-line tools for data recovery.","tsk_recover: tsk_recover recovers files to the output_dir from the image. By default recovers only unallocated files. With flags, it will export all files.","tsk_recover","PhotoRec: PhotoRec is file data recovery software designed to recover lost files including video, documents and archives.","PhotoRec","Here are a couple of recovered files from the WhatsApp Images folder. As I mentioned before, some deleted files are overwritten with existing files. So the data recovery success rate were around 60%."]},{"l":"Anti-Forensic Techniques","p":["Anti-forensic techniques are designed to completely hide data/traces related to a user from the system, making investigation harder for Digital Forensic Investigators. There is both good and bad use cases for Anti- Forensic Techniques. The good situation is when we sell our phone to a stranger or giving away to someone else, It would be better to wipe our phone thoroughly. Because we don't know if they are notorious and have skills in digital forensics. The bad use case would be criminals hiding and destroying evidences."]},{"l":"Disk Wipe","p":["It is the first and foremost Anti-Forensic Technique. Deleting all of the data on a storage device. While simple deletion doesn't prevent recovery, disk wipe make use of secure delete to surpass it. Each sectors from beginning to end of the storage is overwritten using zeros. Individual files can be also securely deleted using file shredders. Android doesn't have much reliable tools for file shredding and disk wiping. The only option is to set the secure startup in FDE devices and set a long password and then format the device couple of times. Same for the FBE devices, format it couple of times to make it impossible to get decryption keys."]},{"l":"File Encryption","p":["As the name suggests, the file encryption technique encrypts files using passwords. In Android, there are many apps for file encryption that makes use of TEE feature. Getting the correct password will be a pain in this context."]},{"l":"Steganography","p":["Steganography is the method of hiding file inside another file. This technique is pretty rare but shouldn't be neglected. For example hiding text inside Audio, Image files etc."]},{"l":"References","p":["Android Partitions","Trusty TEE","Android rooting Guide"]},{"l":"Further Learning","p":["DFIRScience","Awesome Forensics","DFIR Resources","Stark4n6","Alexis Brignoni Blog"]}],[{"l":"Weaponizing Magisk Modules"},{"l":"Introduction","p":["For Educational purpose only. Spreading Malware is a violation of the law, so please don't create and send any malware using the tactics discussed here to anyone. I am not responsible for any damage.","Hello Friends, I am an android enthusiast who loves rooting and modifying android devices. Magisk is an unavoidable element of this task. At some point of time, I wondered what would happen if my device get infected by a Malicious magisk module. Yeah, I often install magisk modules for several mods and tweaks, so there is a chance for this imaginary scenario. And the Malware sources would be shady Telegram channels and websites serving magisk modules.","In this article, we will go through an attack scenario where the threat actor weaponize legitimate Magisk modules for Malicious purpose.","So, what is Magisk and why its an attack vector ?","Magisk is a free and open-source rooting software for Android devices that is widely used in Android modding communities. As a Magisk user myself, I can attest to the fun and excitement that comes with rooting Android devices. With rooting, users can modify CPU schedulers and frequencies to overclock/underclock their device performance, spin up Kali Nethunter to hack their neighbor's wifi (just kidding!, don't do that, its not good \uD83D\uDE42), or completely change system files such as fonts, boot animations, and so on. These are just a few of the possibilities that one can explore by rooting their Android device."]},{"l":"Magisk module","p":["One of the main features of Magisk is its module system, which allows users to automate most tasks by simply flashing a zip file. For example, the previously mentioned features, such as changing fonts, sounds, bootanimations requires typing many commands. But by creating a Magisk module, we can automate all this process with little to no user interaction."]},{"l":"Magisk module structure","p":["A Magisk module folder would look like this, I have only highlighted few files as I am only focusing on backdooring existing module than creating a completely new one.","post-fs-data.sh: Basically executes after installing the module. Handy for copying files around and like that.","service.sh: Think of like a systemd service, executes on every boot and restart of the module daemon.","sepolicy.rule: To set custom SELinux rules like enforcing.","You can refer the Magisk Developer Guides to learn more on Magisk modules."]},{"l":"The Attack Scenario","p":["Attack Chain :-","For our example scenario, I chose the ACC magisk module by VR-25. Then I will include a malicious script in it to obtain reverse shell from the target device.","Description of the module :-","ACC is an Android software mainly intended for extending battery service life. In a nutshell, this is achieved through limiting charging current, temperature, and voltage.","Most modern Android phones have built-in battery life-extending features, but many old phones doesn't support support this feature. ACC module helps in extending battery of old devices."]},{"l":"Backdooring The Magisk module","p":["First step is cloning the repo and collecting the original module files.","Unlike a Linux system, we can't use the normal /dev/tcp reverse shell in Android. Android networking is much more complex, so we need to rely on programs like Netcat or similar alternatives.","Unfortunately, Android doesn't come with Netcat preinstalled, but thankfully Magisk ships with a complete Busybox binary that contains nc and other useful tools.","This makes our task easier, the magisk busybox is located at : /data/adb/magisk/busybox","Backdoor script"]},{"l":"Building the module","p":["The repo had a build script named build.sh, this script automates the entire build process.","Module built successfuly","Luckily our backdoor had no errors."]},{"l":"Installing the module","p":["For convenience, I renamed the module zip to acc_backdoored.zip and pushed it to Downloads folder using adb.","Push the module to device","Module zip file","Pheww, No errors, installation successful.","Installation Success"]},{"l":"Gaining reverse shell","p":["Although we can easily get a reverse shell with nc, I wasn't quite satisfied with it. I wanted something more, which was both easy to use and provided more functionality.","The best and easiest option out there was, of course, our beloved Metasploit Android Meterpreter. And so I created a meterpreter payload and served it on port 8080 using a Python HTTP server.","I am doing this locally, thats why my IP is in 192.168.X.X range.","Reverse shell connected"]},{"l":"Privilege Escalation","p":["We need to download the payload in the target device, again android doesn't come with curl, wget or similar tools. But since we are in the magisk busybox environment, we can use wget to download the payload apk. We can then install the evil.apk using the pm command, which is the core of the conventional Apk Installer system.","Downloading meterpreter","APKs installed through ADB and package manager (PM) are all monitored by Google Play Protect. However, the Metasploit payload is heavily signed by AV providers, hence it is blocked by default. To get things working, I had to disable the App Signature Verification for ADB/ADT in the Developer Options. So on a normal user's device, unless they disabled the verification, meterpreter can't be installed. But this could be bypassed with obfuscation and other AV bypass techniques.","Unfortunately, at first, it didn't work and gave the \"Failed transaction error.\" This is because of SELinux enforcing, which prevents privilege escalation by preventing system service calls and other actions. In order to bypass this, we need to set SELinux enforcing to permissive mode. The setenforce command can be used to temporarily change SELinux to permissive mode.","After changing SELinux to permissive with the setenforce 0 command, we can then install the apk and execute it without encountering any issues.","The am(Activity manager) is used to start the MainActivity of our meterpreter payload.","Finally we got the meterpreter shell. This shell is persistent, whenever the user reboot their device both the nc reverse shell and meterpreter is loaded. All we need to do is keep the listener open.","Meterpreter Success"]},{"l":"Assessing the Malicious module","p":["Assessing module is pretty easy, we just need to extract the module zip file. Since our example module only have shell scripts, it won't be hard to detect. But like I said before, with magisk modules we can change system files, which includes libraries, binaries etc. So finding malicious binaries and libraries would be quite hard and would require great reversing skills."]},{"l":"Reliable sources for downloading Magisk modules","p":["This attack scenario could be real, As you can see there were literally no IOC a normal user can detect. Only chances would be, if the threat actor download all data, then the user can notice increased data usage and act accordingly. But if the attacker is patient enough, then everything will be compromised.","So here are some reliable and safe places where you can download Magisk modules :-","Github","Fox's Magisk Module Manager","XDA Forums","Official Device community and development groups in Telegram"]},{"l":"Conclusion","p":["In conclusion, installing Magisk modules from unknown sources comes with a significant risk that cannot be ignored. Its better to install only essential modules than installing every module you see online. Also checking whats inside the module would be definitely a good practice, when its not from official module github repo and likewise."]}],[{"l":"A Closer Look At Rust Based Malware"},{"l":"Introduction","p":["For Educational purpose only Spreading Malware is a violation of the law, so please don't create and send any malware using the tactics provided here to anyone I am not responsible for any damage All the malware samples are created using the codes taken from OffensiveRust GitHub repository.","In recent years, we have seen a significant increase in the popularity of the Rust programming language. Debates have arisen around Rust's speed, with some arguing that it is faster than C/C++. Notably, Rust has also been used to write kernel drivers for the Linux kernel, which previously only supported C and Assembly code. Furthermore, many popular command-line tools for Linux have been re-implemented in Rust. One such example is the well-known bat tool, a clone of cat with syntax highlighting and other features. These made me wonder why is Rust so popular? and how effective it would be for Offensive Purposes.","In this article, we will analyse some malicious Rust binaries and check their behavior against Windows Defender."]},{"l":"Why Rust So Special?","p":["Rust is a multi-paradigm, high-level, general-purpose programming language. Rust emphasizes performance, type safety, and concurrency. Rust enforces memory safety—that is, that all references point to valid memory—without requiring the use of a garbage collector or reference counting present in other memory-safe languages.","It is fast as C and C++ or sometimes even better.","It is LLVM based.","Easy to cross-compile.","The main reason for its offensive capabilities is the LLVM toolchain, which makes it easier to bypass static analyzers."]},{"l":"Overview Of Rust Binaries","p":["Before testing the Malware Samples, Let's look at a simple calculator program in Rust."]},{"l":"Creating a Rust Project","p":["cargo init rust_calc","Cargo.toml is the config file for cargo package manager. Dependencies and other project configurations can be defined in this file."]},{"l":"Building the Project","p":["~ 1 MB","4.8 MB","5 MB","As you can see, all the function symbols are stripped and its queit hard to understand the program flow.","Build Type","calculator output","cargo build --release to build the release version. The resulting executable will be found under the target\\release\\ directory. Here is the IDA disassembly of the both builds, they are almost same and both include function symbols.","cargo run to run the debug build.","Debug (unoptimized)","Debug Build","Function symbols expose so many informations in static analysis, so it should be stripped for better AV evasion. Fortunately, we just need to add a single line in Cargo.toml for stripping function symbols.","Here is the size of different build variants with default optimization.","IDA view of stripped Rust executable","Release (optimized + non-stripped)","Release (optimized + stripped)","Release Build","Size"]},{"l":"Testing Malware Samples","p":["In this section, we are going to test the classic Process Injection technique. Process injection is a method of executing arbitrary code in the address space of a separate live process. Running code in the context of another process may allow access to the process's memory, system/network resources, and possibly elevated privileges - MITRE T1055","There are many samples with different types of techniques in OffensiveRust github repo, testing them all will make this blog super lengthy. For now, let's test the Local Process Injection and Remote Process Injection samples."]},{"l":"Local Process Injection","p":["Change the shellcode memory permission/protection to Read Execute using VirtualProtect","Copy the shellcode to allocated memory","Create a new Thread using CreateThread with the base address pointing to shellcode memory","Create Thread","Finally call WaitForSingleObject to keep the thread running infinitely","Finally the function casting exec_data eliminates the need for using Windows APIs calls like CreateThread etc.","Finding the correct function in IDA was a bit of annoying, but we can see the shellcode and all other function calls there.","IDA view of CreateThread","Let's do another test, this time using Windows APIs.","link_section specifies the section to use for a function or static, in our sample the shellcode is saved in the .text section and As a result, no need to create any RWX memory for our shellcode.","Local Process Injection - CreateThread Workflow :-","Local Process Injection - Shellcode Local Inject Workflow :-","Shellcode in .text section, starts at offset 0xcb6 and ends at offset 0xdc9","Shellcode Local Inject","Source : OffensiveRust - Process Injection Create Thread","Source : OffensiveRust - Shellcode_Local_Inject","That's all for Local Process Injection, to make things even harder we can use several types of obfuscations on strings and shellcodes, hide the Windows API function traces by manually implementing them and so on. litcrypt crate is an example for string obfuscation.","The no_mangle macro disables symbol name encoding, mangling is the encoding of function and variable names into unique names so that linkers can separate common names in the language. Disabling it is essential for unsafe C codes to access the shellcode.","This is the most basic process injection, saving shellcode in the .text section of the program and execute it without any API calls.","This sample really impressed me, same shellcode but this time shellcode is in stack memory. Literally no detection, the power of Rust obfuscation is really visible here. Windows Defender static analysis were easily defeated.","VirtualAlloc allocates memory for shellcode with Read Write Permission on the current process","Windows Defender easily caught our sample the moment it touched the disk, No wonder because we are putting plain metasploit shellcode in the .text section. Metasploit shellcodes are highly signatured, so its pretty hard to get them running most of the time."]},{"l":"Remote Process Injection","p":["Remote Process Injection is quiet different from the Local Process Injection. In this technique we are loading shellcode or DLL into the memory space of a running process and execute in its context. Imagine \uD83D\uDE01","Source : OffensiveRust - Process_Injection_CreateRemoteThread","Remote Process Injection - CreateRemoteThread Workflow :-","We input a process name in command-line arguement to our sample , eg:- rust_mal.exe notepad.exe","The pid of given process is looked up with the help of CreateToolhelp32Snapshot Windows API function","OpenProcess opens the given remote process with PROCESS_ALL_ACCESS(Gives all possible access rights)","VirtualAllocEx allocate memory in the remote process with RWX permission","Write shellcode to the allocated memory using WriteProcessMemory","Create a thread in the remote process with CreateRemoteThread function, just like in previous sample we point the base address to the shellcode memory","Finally close the process handle","In the latest Windows Defender update this sample was easily caught, but when I tested this sample before 14/02/2023 it was working rather well."]},{"l":"Final Thoughts","p":["When I tested each of these samples with Avast Free Antivirus, all of them were caught instantly. Its anti-exploit protection is impressive. Of course, highly sophisticated threat actors won't use these simple methods, but at least it can prevent skiddies.","To be honest, I was scared to see these samples in action. Rust's ability to bypass static analysis and even behavior analysis against Windows Defender is really impressive. I suggest you to install a better antivirus program such as Avast, Norton, etc. and also avoid running untrusted programs. On top of that, use a Firewall as well for better protection.","Simplewall Firewall","Thank you for taking the time to read my article. I hope it provided you with valuable insights and new knowledge. If you found it enjoyable and informative, I would greatly appreciate it if you could share it with your friends and connections. Your support means a lot to me."]},{"l":"References","p":["https://rayoflightz.github.io/re/rust/2020/05/19/Bite-Sized-Rust-RE-1-Deconstructing-Hello-World.html https://www.pwnthebox.net/rust/2020/11/01/deciphering-no-mangle.html https://cocomelonc.github.io/tutorial/2021/09/18/malware-injection-1.html https://cocomelonc.github.io/pentest/2021/09/29/findmyprocess.html"]}],[{"l":"Reversing Android Malware"},{"l":"Introduction","p":["Malware (Malicious Software) is a type of software that causes harm to your digital devices. These digital viruses can spy on your daily lives, steal money, encrypt files or make your system completely inoperable. Back in the day, computers were the main vector of Malware attacks, but that is now changed. A great number of people own a smartphone, but most aren't practicing good security methods. As a result, attackers are targeting smartphones more in today's digital era.","Today we will reverse engineer and uncover secrets of two different malware."]},{"l":"Prerequisites","p":["The tools we will be using to analyse the characteristics of malware are ,","JADX-GUI- Dex to Java decompiler","MobSF- MobSF is an automated, all-in-one mobile application (Android/iOS/Windows) for pen-testing, malware analysis, and security assessment framework capable of performing static and dynamic analysis.","Ghidra- Ghidra is a software reverse engineering (SRE) framework","JADX and MobSF require JRE 8 or above.","Installation methods for JADX,","Linux [JADX]","Windows [JADX]","Installation methods for MobSF,","Linux [MobSF]","Windows [MobSF]"]},{"l":"Analysis"},{"l":"Meterpreter Malware","p":["An intent is an abstract description of an operation to be performed. It can be used to start an activity, send intents to BroadcastRecievers, etc. In our case, the BOOT_COMPLETED intent is received by MainBroadcastReceiver.","ApkBleach is a python script to pack/obfuscate meterpreter malware which has many features.","Awesome, we got the C2 IP from a unpacked/non-obfuscated malware.","BOOT_COMPLETED intent is sent when the device boot after proper shutdown, and restart isn't affected.","Decoding few bytes from the array using python to print ASCII characters.","Decompiling the MainBroadcastReceiver class gives us a better understanding of the persistence mechanism.","Eventhough we apply some simple obfuscation techniques Defenders and Reverse Engineering techniques are smart enough today to analyse and categorize this malware.","First of all, lets understand the structure of an apk file.","From the MainBroadcastReceiver it can be observed that the persistence mechanism is dependent on,","From the reversed output of the source code from the APK, it can be observed that the APK uses some notable classes:","If the received intent is android.intent.action.BOOT_COMPLETED, receiver starts the MainService which is a staged payload","img","In the permissions tab, we can see the permissions requested by the app. This data is fetched from AndroidManifest.xml file.","It can be observed that the ApkBleach obfuscates keywords to bypass detection. But this is not enough to overcome smart defenders which are being used in the wild today.","MainActivity","MainBroadcastReciever","MainService","Meterpreter asks for many dangerous permissions such as READ_CALL_LOG, READ_SMS, READ_CONTACTS etc. This clearly indicates its a bad application requesting for unauthorized access. MobSF also extracts cleartext IPs and URLs from app source codes and checks them on VirusTotal, with this feature we can see if there exist any Malicious servers. But in our Meterpreter case, the C2 Server IP address is not in plaintext format. As a result, it isn't detected by MobSF.","Meterpreter can talk to Command & Control (C2) Server using TCP, HTTP, and HTTPS protocols. For more info on Metasploit Android Modules, refer here.","Now its time to use Jadx-GUI. On the left-pane, we can see source code and resources. Currently, I have opened the AndroidManifest.xml of the app. We can see the permissions and other pieces of information.","Now reversing the Payload class which is pretty big containing shellcodes for our RAT. We will be decoding our LHOST value from this class which is converted into other data type.","Payload","Reference : https://en.wikipedia.org/wiki/Apk_(file_format)","Since it is converted into other type we could not find our C2 IP address using search feature. Looking through the code and the first-byte array a seems like a converted data type object. The byte data type is an 8-bit signed two's complement integer. It has a minimum value of -128 and a maximum value of 127 (inclusive). The printable characters in ASCII are from 33 to 126. So the byte array may have printable characters.","The above image refers the typical structure of a APK file","The arguments required for successful tunnel creation for the RAT and C2 server are LHOST : Attacker IP Address (CONTROL SERVER) and LPORT : Attacker Port","The below onliner command is used to craft a meterpreter RAT using Metasploit Framework,","The highlighted line in the above screenshot plays a vital role in functioning as RAT. Let's break down that method because it's a persistence mechanism.","The MainBroadcastReciever listen for Broadcast Intents","The Meterpreter is a RAT (Remote Access Trojan) type Malware. Once executed on the victim's device, it will grant an attacker complete access to the device.","This sums up the static analysis of Meterpreter Malware.","We will use MobSF to get an overview of the App. This tool saves lots of time when compared to manually analyzing each component of the app, also every piece of information is well documented by the MobSF framework."]},{"l":"XLoader/MoqHao Malware","p":["( arg-types ) ret-type: method type","[type: type[]","Always keep your device up to date and never install apps from third-party sites, this will reduce the chance of installing malware. Nowadays, Google Playstore has become an attack vector to spread malware, so cautiously install apps from Playstore either.","Analysing the malware in VirusTotal flags it as suspicious","As you can see, there aren't many methods in this Malware, and it's packed (obfuscated). Even some permissions are obfuscated. Additionally, this Malware comes with a native library libvga.so which is under lib/armeabi-v7a and a file named 1bmurb1 under assets/mvmc, which is the encrypted payload of this Malware. The payload is decrypted on the runtime to evade detection.","B: byte","Breakdown of the above shown code in short context:","By checking the native library functions in ghidra, we can see that native methods are defined in the format of Java_mangled_class_name_mangled_method_name.","C: char","D: double","Decompiling the Java_s_ni_pi function using Ghidra,","Decompiling using HexRays IDA Decompiler the decompilation is much clear now. In this output, v23 is the XOR key where it is retrieved from v23 = v61[11]. v61 is passed to the read method and it holds the encrypted data of the payload file. That means the XOR key is the 12th byte of the encrypted payload file 1bmurb1.","Decompress the XORed payload with Inflate Algorithm","F: float","For the second Analysis, I chose XLoader Malware Sample from MalwareBazaar. This one is entirely different from Meterpreter Malware and tricky to reverse.","Here is the summary of the XLoader Malware:","I: int","img","JNI Type Signatures :","L: fully-qualified-class","Load the payload to InputStream","Loading our malware into MobSF Framework to perform static analysis","Loading the decrypted DEX file in jadx-GUI to view the payload","mvmc object, which is the name of the asset folder is passed to method c","Native libraries are libraries written in C/C++ or other languages. Apps can access native libraries through JNI ( Java Native Interface ) programming Interface. The native keyword is used to implement JNI methods. In our sample, The package s has the implementation of the native methods.","ni.iz executes the payload object","ni.oa returns Class object after loading the result of ni.ls","S: short","The GNuApplication is the main class that interacts with the native library.","The JNINativeMethod requires method signatures to handle arguments and return types. It is listed in Type Signatures section on JNI docs.","The ni.pi method decrypts the payload file , ni.ls load the decrypted payload with com.Loader","The obfuscated permissions from GNuApplication are,","The System.loadLibrary(vg) method loads the libvg.so native library","The XLoader/MoqHao Malware is a banking Trojan which mainly targets Japanese and South Korean Android Users. It has many features like sending and receiving SMS, changing audio ringer settings, installing malicious apps, spying on user activities and device status, etc. Our sample was targeting users of japaneses banks like Sumitomo Mitsui Banking Corporation.","V: void","We can see the AssetManager being called in the decompiled code of Java_s_ni_pi method shown below. The payload is processed with the following steps.","We have successfully decrypted the payload file and we can see the decompilation of payload file is pretty tricky.","We will use ghidra to decompile the native library. This library is flagged as a Trojan dropper and considered as malicious.","With the help of Cryptax's MoqHaoUnpacker, I was able to decrypt the payload. The decrypted payload is a dex file.","XOR the payload with a key","Z: boolean"]},{"l":"References","p":["Unpacking the Packed Unpacker: Reverse Engineering an Android Anti-Analysis Native Library - by Maddie Stone","Azeria Labs - ARM Assembly Basics"]}]]