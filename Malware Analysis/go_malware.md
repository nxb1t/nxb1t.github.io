---
author:
    name: nxb1t
    avatar: https://nxb1t.is-a.dev/assets/img/profile.jpeg
date: 2025-09-20
category:
    - Malware Analysis
    - Reverse Engineering
tags: [Malware Analysis, Reverse Engineering]
---

# Analyzing A GO Malware

![](/assets/img/go_malware/cover.png)

Hello Friends, <br>
This post covers my analysis of a Linux-based Go malware sample. It used anti-VM evasion techniques, which made it harder for sandbox environments to detect. Reverse engineering this sample was really interesting, especially the C2 agent and data exfiltration parts, which operated in unexpected ways.

## Overview

---

The sample analyzed was a multi-stage Go-based loader designed to fetch, decrypt, and execute multiple payloads. Its modular structure allowed each stage to handle a specific responsibility, gradually building toward full system compromise and data exfiltration.

* Stage 1 – Initial Loader<br>
The first stage downloads two components: `access` and `inter_ddns`. The access binary is responsible for decrypting inter_ddns, enabling the next execution phase.

* Stage 2 – Core Loader (inter_ddns)<br>
Once decrypted, inter_ddns operates as the core loader. It retrieves four additional binaries — `access2`, `server2`, `access3`, and `drive` — and executes them sequentially.

* Stage 3 – Command & Control<br>
The server2 binary establishes communication with the Command-and-Control (C2) server, enabling remote access control.

* Stage 4 – Data Exfiltration<br>
The drive binary is responsible for exfiltrating files to Google Cloud Platform (GCP), completing the attack chain.

![](/assets/img/go_malware/diagram.png)

=== MITRE ATT&CK Tactics

| ATT&CK Tactic       | ATT&CK Technique ID | Technique Name   |
| ------------------- | ------------------- | ---------------- |
| Execution           | T1204               | User Execution   |
| Persistence         | T1543.002           | Systemd Service  |
| Defense Evasion     | T1622<br>T1070.004<br>T1140 | Debugger Evasion <br> File Deletion <br> Decode Files |
| Command and Control | T1219               | Remote Access Tools |
| Exfiltration        | T1567.002           | Exfiltration to Cloud Storage|

===


## Why Go is a Popular Choice for Threat Actors

---

So, why are threat actors turning to Go? The answer is simple and lies in some of the language's core features:

* **Static Linking**: Go binaries are statically linked by default, which means they include all necessary dependencies. This makes the malware highly portable, as it can be run on any system without worrying about missing libraries. This also often results in a larger binary size, which can help it evade some signature-based detection systems.

* **Native Cross-Compiling**: Go's built-in support for cross-compilation is a huge advantage. A developer can write a single codebase and easily compile it for different operating systems (like Windows, macOS, and Linux) and architectures.

* **Ease of Use**: Compared to languages like C or C++, Go is relatively easier to code.

With the help of AI it is even easier to write custom malware and C2 infrastructures using go lang.

!!! Note
There are many resources available for detailed information on Go Lang binary internals, which you can check out here :-

[Golang Reverse Engineering Tips - Travis Mathison](https://www.travismathison.com/posts/Golang-Reverse-Engineering-Tips/#golang-type-system) <br>
[Go Internals and Symbol Recovery - Google Threat Intelligence](https://cloud.google.com/blog/topics/threat-intelligence/golang-internals-symbol-recovery/)

Including all those topics would make this blog too long, so feel free to explore them separately.

!!!

https://www.youtube.com/watch?v=mgCZJYRlHDI&t=1843s

## Analysis

---

Except for the server2 payload, all other payloads were Go-based. I used the following tools to analyze them:

* [IDA Free](https://hex-rays.com/ida-free)
* [redress](https://github.com/goretk/redress/tree/master)
* [CAPEv2 Sandbox](https://github.com/kevoreilly/CAPEv2)
* [Detect-it-Easy](https://github.com/horsicq/Detect-It-Easy)

IDA Free performed better than Ghidra and Binary Ninja when decompiling Go binaries, as IDA automatically rebuilds the PCLN and recovers most of the symbols.

redress is an excellent tool for analyzing stripped Go binaries. It provides detailed information about Go packages and source files.

Finally, CAPE was used to extract C2 information from the server2 payload, as it was a MeshAgent.

### Loader 1

==- File Details

| Property | Value |
| -------- | ----- |
| Name     | Initial Loader |
| SHA256   | 2fb4106def39ac5bf8e20eded90d9cfbdbbb925ca3b98cde3f815ac99eaeb474  |
| MD5      | 0ddc790155c2c844babe8ca7d500439a |
| Language | Go |

===

The name of the file may vary depending on the delivery method used by the threat actors, so I would refer to the binary as the Initial Loader. The purpose of the Initial Loader is to deliver an encrypted second-stage component, which then downloads and executes the final C2 agent and exfiltrator payloads.

Using the Redress tool, we obtained a clear overview of the Go binary, including the original package name, `ddns`. The analysis also indicated that the threat actors were building these malware payloads in a Kali VM.

![loader1 info](/assets/img/go_malware/loader1_redinfo.png)

**Functions List**

![loader1 source](/assets/img/go_malware/loader1_redress.png)

The loader first checks if the system is running inside a virtual machine by calling RealCheck function. It then verifies if the internet connectivity is present through HomeChecker. If no connection is detected, a [Zenity](https://help.gnome.org/users/zenity/stable/index.html.oc) error dialog is displayed with "Boss Internet Issue".
If the loader detects VM, it self-deletes and remove all traces by calling the HiddenHome function.

Finally, the loader decrypts a set of encrypted URLs using the decrypt function. From these URLs, it retrieves additional stagers via the downloadFile function and executes them.

![Main Function](/assets/img/go_malware/loader1_main.png)

==- RealCheck Function

The loader attempted to determine whether it was running inside a virtual machine by reading system files such as /sys/class/dmi. Probably the threat actors used ChatGPT or similar AI tools based on the level of plain VM checks.

![RealCheck Function](/assets/img/go_malware/loader1_realcheck.png)

===

==- HiddenHome Function

The HiddenHome function is responsible for self-deletion. When invoked, the loader executes an rm -rf command to remove its own binary and erase traces from the system.

![HiddenHome Function](/assets/img/go_malware/loader1_hidden.png)

===

==- HomeChecker Function

The HomeChecker function verifies internet connectivity by sending a ping request to Google. If the connection check fails, the loader assumes the system is offline and halts further execution.

![HomeChecker Function](/assets/img/go_malware/loader1_homechecker.png)

===

==- decrypt Function

The decrypt function accepts three arguments: the ciphertext, the DES key, and the IV. It first decodes the ciphertext from Base64, then initializes a DES cipher in CBC mode using the provided key and IV. After decryption, the resulting plaintext is used as configuration data, such as payload download URLs.

![decrypt Function](/assets/img/go_malware/loader1_decrypt.png)

Based on the disassembly, I crafted an potential source code for the function.

```go
func decrypt(cipherEncoded string, keyEncoded string, ivEncoded string) {
    cipher, _ := base64.StdEncoding.DecodeString(cipherEncoded)
    key, _ := base64.StdEncoding.DecodeString(keyEncoded)
    iv, _ := base64.StdEncoding.DecodeString(ivEncoded)
    block, _ := des.NewCipher(key)
    mode := cipher.NewCBCDecrypter(block, iv)
    plain := make([]byte, len(cipher))
    mode.CryptBlocks(plain, cipher)
}
```

![Decrypting the URLs using CyberChef](/assets/img/go_malware/loader1_cyberchef.png)

===

The loader contained three encrypted strings: two corresponding to drive URLs and one serving as the password required to decrypt the inter_ddns payload.

| Extracted Texts |
| --------------- |
| https[:]//drive.google.com/uc?export=download&id=1g1AgwMnUTEV1HHmQkcH-eTww3w8et82m (access) |
| https[:]//drive.google.com/uc?export=download&id=1UFD10tcoPJZIBpF4hcz6orM1C57uivI7 (inter_ddns) |
| WOrkiNgtoDesksSS8123whyme?youseethis |

The threat actors used the email address `simonedaira@gmail.com` to share the payloads via Google Drive. A lookup in Epieos revealed that the account had been updated only recently.

![](/assets/img/go_malware/threatintel.png)

After downloading the two files, the loader decrypts the final string and uses it as an argument when executing the access binary.

![downloadFile Function - decrypting strings](/assets/img/go_malware/loader1_exec.png)

The loader tries to execute `access` binary with args `-f inter_ddns` and `-d WOrkiNgtoDesksSS8123whyme?youseethis`.

![downloadFile Function - Args](/assets/img/go_malware/loader1_args.png)

After that, the loader executes the decrypted inter_ddns payload and then calls the HiddenHome function to remove all of its traces.

![downloadFile Function - calling HiddenHome](/assets/img/go_malware/loader1_final.png)

The remaining responsibilities are handed over to inter_ddns, but before analyzing it, let’s first examine the access binary.

### Decrypter

==- File Details

| Property | Value |
| -------- | ----- |
| Name     | access |
| SHA256   | 231957a5b5b834f88925a1922dba8b4238cf13b0e92c17851a83f40931f264c1  |
| MD5      | c1b3a940888c5677c6d9f3df7a550385 |
| Language | Go |

===

The access binary was packed with UPX and functioned as an encrypter/decrypter. It supported help argument that displayed all available options. The binary was capable of both RC4 and AES decryption.

![access info](/assets/img/go_malware/access_init.png)

**Functions List**

![access source](/assets/img/go_malware/access_source.png)

The decrypter first calls the processFile function, which receives the provided password and file name as arguments. Depending on the selected decryption option (aes or rc4), the password is hashed using either SHA-256 (for AES) or MD5 (for RC4).
The function then reads the target file and passes the data to the processBytes function, which handles the actual decryption. Inside processBytes, execution branches to either aesDecryptEncrypt or rc4DecryptEncrypt, depending on the chosen algorithm.

![processFile function](/assets/img/go_malware/access_procfile.png)


==- aesDecryptEncrypt Function

For AES decryption, the malware uses CTR mode. The encryption key is derived by computing the SHA-256 hash of the provided password. This derived key is then used to perform decryption on the target data.

![](/assets/img/go_malware/access_aes.png)

===

Using the password `WOrkiNgtoDesksSS8123whyme?youseethis` we decrypted inter_ddns which was another go based binary.

![](/assets/img/go_malware/access_decrypt.png)

### Loader 2

==- File Details

| Property | Value |
| -------- | ----- |
| Name     | inter_ddns |
| SHA256   | 38b6b93a536cbab5c289fe542656d8817d7c1217ad75c7f367b15c65d96a21d4  |
| MD5      | b5e8cda59477773002d80127f82d7e8b |
| Language | Go |

===

Unlike the first loader, this second-stage loader carries broader responsibilities beyond just downloading and executing payloads. It establishes persistence on the system and deploys the final C2 agent along with the Exfiltrator payload.

**Functions List**

![](/assets/img/go_malware/loader2_source.png)

The loader begins by checking for VM artifacts. If none are found, it proceeds to download `access2` and `server2` via the download function. The loader then decrypts the password required by access2 to unlock server2, which is subsequently executed as the C2 agent. To maintain long-term access, the `livingoftheland` functions establishes persistence, after which the `selfdelete` function removes the binary to minimize forensic traces.

In the next stage, the loader retrieves and executes `access3` and `drive`. Once executed, access3 is deleted while persistence remains intact. The process concludes with the removal of the inter_ddns binary, completing the full attack cycle.

!!!
The newly downloaded access binaries are essentially same as the first `access` binary.
!!!

![Main function](/assets/img/go_malware/loader2_main.png)

==- livingoftheland Function

The first function, `livingoftheland1`, establishes persistence for the `server2` C2 agent by creating a systemd service under `$HOME/.config/systemd/user/`. Once the service is created, it is immediately started and enabled to run on user login.

![livingoftheland1](/assets/img/go_malware/loader2_persistence1.png)

The second function, `livingoftheland2`, performs a similar role to the previous function. However, in this instance, it establishes persistence specifically for the `drive` binary

![livingoftheland2](/assets/img/go_malware/loader2_persitence2.png)

===

| Extracted Texts |
| --------------- |
| https[:]//drive.google.com/uc?export=download&id=1g1AgwMnUTEV1HHmQkcH-eTww3w8et82m (access2) |
| https[:]//drive.google.com/uc?export=download&id=1ygXFO_RLAfvjfBS1go5qWX93o7RGLhhf (server2) |
| https[:]//drive.google.com/uc?export=download&id=1g1AgwMnUTEV1HHmQkcH-eTww3w8et82m (access3) |
| https[:]//drive.google.com/uc?export=download&id=19i_DeH_tPVAeXULN0W3zDLxokoQE5UcU (drive) |

### C2 Agent

==- File Details

| Property | Value |
| -------- | ----- |
| Name     | server2 |
| SHA256   | 05b468fc24c93885cad40ff9ecb50594faa6c2c590e75c88a5e5f54a8b696ac8 |
| MD5      | ddb0023ed29ffff42650cdcaeff2a663 |
| Language | C |

===

What stands out in this case is that, instead of deploying a custom C2 agent, the threat actors leveraged MeshAgent, an open-source remote management tool.

![Detect-It-Easy](/assets/img/go_malware/c2_diec.png)

This agent can be connected to their custom hosted MeshCentral server which allows all sort of Remote access.

![Main Function](/assets/img/go_malware/c2_main.png)

For simplicity, the sample was run inside the CAPE sandbox, as it didn't had any evasion techniques and we were able to extract the C2 server information : <br> `boss-servers.gov.in.indianbosssystems.ddns.net`

![CAPE Analysis](/assets/img/go_malware/c2_cape.jpg)

While checking this C2 domain we got the information about server which was hosted in AWS EC2.

![C2 Server](/assets/img/go_malware/c2details.png)

Further investigation of the domain revealed that multiple domains were pointing to the same EC2 IP address: `54.144.107.42`

![C2 Domains](/assets/img/go_malware/c2_threatintel.png)

The portal had some login page however couldn't interact with it much.

![C2 Portal](/assets/img/go_malware/c2web.png)

### Exfiltrator

==- File Details

| Property | Value |
| -------- | ----- |
| Name     | drive |
| SHA256   | a7471e871f5b23cb0de247fc4f240a88cdc4bd4069089a660cc3292f0910daa8  |
| MD5      | 5c79a127162b9fce72947399fe56f215 |
| Language | Go |

===

The exfiltrator had many functions for maximum data collection and leveraged a Google Cloud Platform (GCP) service account to exfiltrate data directly to Google Drive.

Similar to previous payloads, it performs anti-VM checks, examines os-release using the EasyFel function, and additionally collects the device's MAC address, username, and hostname metadata.

It scans for all common non-zero byte files present in user local directories and mounted paths, collects the hosts file, and generates metadata for all files, which are uploaded alongside the files. It also monitors directories and mount paths for new files and repeats the exfiltration process whenever new files are found.


**Functions List**

![](/assets/img/go_malware/exfil_source.png)

==- UploadFiles functions

They check for all kind of files with the help of `find` command and collect them from user's home directory and local directories.

![](/assets/img/go_malware/exfil_localdir.png)

It also checks for USB drives mounted on the system and exfiltrate from the drives.

![](/assets/img/go_malware/exfil_usbfiles.png)

===


==- getServiceAccountJSON function

In this function the service account token is being decrypted.

![](/assets/img/go_malware/exfil_servicetoken.png)

However, when I checked the associated service account were already deactivated or removed.

![](/assets/img/go_malware/service_token.png)

Finally the collected files are uploaded to drive.

![](/assets/img/go_malware/exfil_drive.png)

===

## IOC List

---

| Type | Value | Description |
| ---- | ----- | ----------- |
| MD5 | 0ddc790155c2c844babe8ca7d500439a   |   `Initial Loader`  |
| MD5 | c1b3a940888c5677c6d9f3df7a550385   |   `access1,2,3`  |
| MD5 | 7bf644d99f672f2d1c300194ba512f10   | `inter_ddns` (encrypted) |
| MD5 | b5e8cda59477773002d80127f82d7e8b   | `inter_ddns` (decrypted) |
| MD5 | 4f538bda80f0e6d49e2302b941ff1d74   |  `server2` (encrypted)          |
| MD5 | ddb0023ed29ffff42650cdcaeff2a663   |  `server2` (decrypted)            |
| MD5 | fe60b38c9b873a591b3744f6f26c8982   |  `drive` (encrypted)           |
| MD5 | 5c79a127162b9fce72947399fe56f215   |  `drive` (decrypted)          |
| DOMAIN | boss-servers.gov.in.indianbosssystems.ddns.net    |   C2 Domain         |
| IP   |  54.144.107.42     |    C2 IP         |
